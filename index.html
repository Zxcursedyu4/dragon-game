<style>
    /* Добавляем новые стили анимаций */
    .hp-flash {
        animation: hpPulse 0.5s ease-in-out;
    }

    @keyframes hpPulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); }
        100% { transform: scale(1); }
    }

    .heal-effect {
        position: absolute;
        background: rgba(76, 175, 80, 0.3);
        border-radius: 50%;
        pointer-events: none;
        animation: healPulse 0.8s ease-out;
    }

    @keyframes healPulse {
        0% { 
            transform: scale(0.5);
            opacity: 1;
        }
        100% { 
            transform: scale(2);
            opacity: 0;
        }
    }
</style>

<script>
    // Модифицированная функция изменения HP
    function updateHP(newValue) {
        const prevHP = dragon.hp;
        dragon.hp = Math.max(0, Math.min(dragon.maxHp, newValue));
        
        if(dragon.hp <= 0 && prevHP > 0) {
            dragon.healTime = Date.now() + 7200000;
            showDeathTimer();
            addLog('Поражение! Восстановление через 2 часа.');
        }
        
        // Анимации
        if(dragon.hp > prevHP) {
            createHealEffect();
            document.getElementById('hpBar').classList.add('hp-flash');
        }
        
        updateUI();
        localStorage.setItem('dragon', JSON.stringify(dragon));
    }

    // Создаем эффект лечения
    function createHealEffect() {
        const effect = document.createElement('div');
        effect.className = 'heal-effect';
        effect.style.left = `${Math.random() * 80 + 10}%`;
        effect.style.top = `${Math.random() * 80 + 10}%`;
        document.body.appendChild(effect);
        setTimeout(() => effect.remove(), 800);
    }

    // Модифицированная функция атаки
    function playerAttack() {
        if(!currentEnemy || dragon.healTime > 0) return;
        
        // Атака игрока
        const stageMult = stages[dragon.stage].mult;
        const dmg = Math.floor(Math.random() * 10 * stageMult) + 1;
        currentEnemy.hp = Math.max(0, currentEnemy.hp - dmg);
        addLog(`Вы нанесли ${dmg} урона!`);
        
        // Атака врага
        const enemyDmg = Math.floor(Math.random() * currentEnemy.attack) + 1;
        updateHP(dragon.hp - enemyDmg);
        addLog(`${currentEnemy.name} наносит ${enemyDmg} урона!`);
        
        document.getElementById('fightEnemyHP').textContent = Math.max(0, currentEnemy.hp);
        
        if(currentEnemy.hp <= 0) {
            const xpGain = Math.floor(currentEnemy.maxHp * (1 + dragon.stage/2));
            dragon.xp += xpGain;
            addLog(`Победа! +${xpGain} опыта!`);
            currentEnemy = null;
            checkEvolution();
            nextScreen('main');
        }
    }

    // Обновленная функция восстановления HP
    setInterval(() => {
        if(!dragon.inCombat && dragon.hp < dragon.maxHp && dragon.healTime === 0) {
            updateHP(dragon.hp + 1);
        }
    }, 300);

    // Модифицированная функция показа таймера
    function showDeathTimer() {
        const overlay = document.getElementById('deathOverlay');
        overlay.style.display = 'flex';
        document.querySelectorAll('button').forEach(btn => btn.disabled = true);
        
        const updateTimer = () => {
            const remaining = dragon.healTime - Date.now();
            if(remaining <= 0) {
                overlay.style.display = 'none';
                dragon.hp = dragon.maxHp;
                dragon.healTime = 0;
                document.querySelectorAll('button').forEach(btn => btn.disabled = false);
                updateUI();
                return;
            }
            
            const hours = Math.floor(remaining / 3600000);
            const minutes = Math.floor((remaining % 3600000) / 60000);
            const seconds = Math.floor((remaining % 60000) / 1000);
            
            document.getElementById('deathTimer').textContent = 
                `${hours.toString().padStart(2, '0')}:` +
                `${minutes.toString().padStart(2, '0')}:` +
                `${seconds.toString().padStart(2, '0')}`;
            
            requestAnimationFrame(updateTimer);
        };
        
        updateTimer();
    }

    // Обновленная функция UI
    function updateUI() {
        const stage = stages.find(s => dragon.xp >= s.xp) || stages[0];
        dragon.stage = stages.indexOf(stage);
        
        // Обновление иконки
        document.getElementById('dragonIcon').textContent = stage.icon;
        
        // XP
        document.getElementById('currentXP').textContent = dragon.xp;
        const nextStage = stages[dragon.stage + 1] || {xp: Infinity};
        const xpPercent = (dragon.xp - stage.xp) / (nextStage.xp - stage.xp) * 100;
        document.getElementById('xpBar').style.width = `${xpPercent}%`;
        
        // HP
        document.getElementById('currentHP').textContent = Math.floor(dragon.hp);
        document.getElementById('maxHP').textContent = dragon.maxHp;
        document.getElementById('hpBar').style.width = `${(dragon.hp / dragon.maxHp) * 100}%`;
        
        // Кнопка кормления
        const feedCooldown = Date.now() - dragon.lastFeed;
        const remaining = 3600000 - feedCooldown;
        const isFeedDisabled = remaining > 0 || dragon.healTime > 0;
        
        document.getElementById('feedBtn').disabled = isFeedDisabled;
        
        let timerText = '';
        if(remaining > 0) {
            const minutes = Math.floor(remaining / 60000);
            const seconds = Math.floor((remaining % 60000) / 1000);
            timerText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        document.getElementById('feedBtn').innerHTML = `
            Покормить
            ${remaining > 0 ? `<div class="feed-timer">${timerText}</div>` : ''}
        `;
        
        // Убираем класс анимации после завершения
        setTimeout(() => {
            document.getElementById('hpBar').classList.remove('hp-flash');
        }, 500);
    }
</script>